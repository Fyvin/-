    """最小二乘拟合圆"""
    def fit_circle_geometric(self, points):
        from scipy.optimize import least_squares
        x = np.array([p[0] for p in points])
        y = np.array([p[1] for p in points])

        def residuals(params):
            a, b, r = params
            return np.sqrt((x - a) ** 2 + (y - b) ** 2) - r

        x_m, y_m = np.mean(x), np.mean(y)
        r0 = np.mean(np.sqrt((x - x_m) ** 2 + (y - y_m) ** 2))
        res = least_squares(residuals, [x_m, y_m, r0])
        a, b, r = res.x
        return (a, b), r

    def fit_circle_taubin(self, points):
        x = np.array([p[0] for p in points])
        y = np.array([p[1] for p in points])
        x_m = np.mean(x)
        y_m = np.mean(y)
        u = x - x_m
        v = y - y_m
        Suu = np.sum(u ** 2)
        Suv = np.sum(u * v)
        Svv = np.sum(v ** 2)
        Suuu = np.sum(u ** 3)
        Svvv = np.sum(v ** 3)
        Suvv = np.sum(u * v ** 2)
        Svuu = np.sum(v * u ** 2)

        A = np.array([[Suu, Suv], [Suv, Svv]])
        B = np.array([(Suuu + Suvv) / 2, (Svvv + Svuu) / 2])
        uc, vc = np.linalg.solve(A, B)

        a = x_m + uc
        b = y_m + vc
        r = np.sqrt(uc ** 2 + vc ** 2 + (Suu + Svv) / len(x))
        return (a, b), r

    def fit_circle(self, points):
        # points为10个点的列表，格式：[[x1,y1], [x2,y2], ..., [x10,y10]]
        x = np.array([p[0] for p in points])
        y = np.array([p[1] for p in points])
        A = np.vstack([2 * x, 2 * y, np.ones_like(x)])
        # 构造系数矩阵A和常数项矩阵B
        A = np.vstack([2 * x, 2 * y, np.ones_like(x)]).T  # 形状为(10,3)
        B = x ** 2 + y ** 2  # 形状为(10,)

        # 求解最小二乘解：[a, b, a²+b²-r²]
        sol, _, _, _ = np.linalg.lstsq(A, B, rcond=None)
        a, b, c = sol  # a=圆心x，b=圆心y
        # 计算半径（可选）
        # r = np.sqrt(a ** 2 + b ** 2 - c)
        r = np.mean(np.sqrt((x - a) ** 2 + (y - b) ** 2))

        return (a, b), r  # 返回圆心和半径


    """RANSAC 拟合圆"""
    def ransac_fit_circle(self, points, area_r=(700, 1500), threshold=1, max_iter=100, min_inliers=200):
        """
        RANSAC圆拟合核心函数
        :param points: 输入轮廓点集 (N,2)，来自findContours
        :param threshold: 内点判定阈值（点到圆的距离误差）
        :param max_iter: 最大迭代次数
        :param min_inliers: 判定“好圆”的最小内点数
        :return: 最优圆参数 (cx, cy, r)，无合格圆则返回None
        """
        best_inliers = []  # 存储最优内点
        best_circle = None  # 存储最优圆参数

        for _ in range(max_iter):
            # 1. 随机抽取3个不重复的点
            sample_idx = np.random.choice(len(points), 3, replace=False)
            p1, p2, p3 = points[sample_idx]
            mask = np.ones(len(points), dtype=bool)
            mask[sample_idx] = False
            remain_points = points[mask]
            x1, y1 = p1;
            x2, y2 = p2;
            x3, y3 = p3

            # 2. 判断3点是否共线（共线则无法确定圆，跳过此次迭代）
            # 共线判定：向量叉积为0（简化为计算斜率差，避免浮点误差用乘积判断）
            if (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1):
                continue

            # 3. 计算3点确定的圆（解圆的一般方程：x²+y²+Dx+Ey+F=0）
            A = np.array([
                [x1, y1, 1],
                [x2, y2, 1],
                [x3, y3, 1]
            ])
            B = -np.array([x1 ** 2 + y1 ** 2, x2 ** 2 + y2 ** 2, x3 ** 2 + y3 ** 2])
            D, E, F = np.linalg.solve(A, B)  # 求解圆参数
            # 4. 计算圆心和半径（由一般方程推导）
            cx = -D / 2
            cy = -E / 2
            r = np.sqrt((D ** 2 + E ** 2) / 4 - F)
            # 过滤异常半径（避免过小/过大的无效圆）
            if r < area_r[0] or r > area_r[1]:
                continue

            # 5. 统计内点（所有点到圆的误差 ≤ threshold 为内点）
            # 点到圆的误差：|√((x-cx)²+(y-cy)²) - r|，简化为平方差避免开方
            errors = np.abs(np.sqrt((remain_points[:, 0] - cx) ** 2 + (remain_points[:, 1] - cy) ** 2) - r)
            inliers = remain_points[errors <= threshold]

            # 6. 更新最优模型（内点数更多则替换）
            if len(inliers) > len(best_inliers) and len(inliers) >= min_inliers:  # 内点数>上一轮/最优内点, 内点数>最小投票数
                best_inliers = inliers
                best_circle = (cx, cy, r)
            if best_circle:
                return best_circle
            else:
                return []


    """最小外接圆"""
    def _detect_circle(self, contours, bgr, img_w,
                       radius_r, full_r, circle_area_r, flag):
        if radius_r is None:
            radius_r = (0, 1e9)
        if full_r is None:
            full_r = 0.8

        centers, used_cnts = [], []
        for cnt in contours:
            (x, y), r = cv2.minEnclosingCircle(cnt)
            contour_area = cv2.contourArea(cnt)
            circle_area = np.pi * r * r
            fill_ratio = contour_area / (circle_area + 1e-9)

            if not (radius_r[0] <= r <= radius_r[1]):
                continue
            if not (circle_area_r[0] <= contour_area <= circle_area_r[1]):
                continue
            if fill_ratio < full_r:
                continue
            if flag and x > img_w / 2 and r < 500:
                continue

            cv2.circle(bgr, (int(round(x)), int(round(y))), int(round(r)), (0, 0, 255), 3)
            centers.append((round(x, 3), round(y, 3), round(r, 3)))
            used_cnts.append(cnt)

        return centers, bgr, used_cnts
